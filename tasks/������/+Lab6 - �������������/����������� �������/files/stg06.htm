<html>
<head>
<title>Stegangraphy - Audio</title>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
</head>

<body bgcolor="#EBF4D5" text="#0b0ba6">
<p align="center"><object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=4,0,2,0" width="50" height="70">
    <param name=movie value="button10.swf">
    <param name=quality value=high>
    <param name="BASE" value=".">
    <param name="BGCOLOR" value="#ebf4d5">
    <embed src="button10.swf" base="."  quality=high pluginspage="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="50" height="70" bgcolor="#ebf4d5">
    </embed> 
  </object><object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=4,0,2,0" width="50" height="70">
    <param name=movie value="button11.swf">
    <param name=quality value=high>
    <param name="BASE" value=".">
    <param name="BGCOLOR" value="#ebf4d5">
    <embed src="button11.swf" base="."  quality=high pluginspage="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="50" height="70" bgcolor="#ebf4d5">
    </embed> 
  </object><br>
  <font color="00790A"><b><font size="4" face="Arial, Helvetica, sans-serif">Аудиостеганография 
  (методы, сравнительный анализ методов).</font></b></font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Восприятие звука 
  человеком осуществляется в больших пределах частот. Человек также очень чувствителен 
  к шумам в звуковых файлах (80 dB по отношению к окружающему уровню звука). Однако, 
  существует несколько особенностей, которые позволяют скрывать данные в звуковых 
  файлах.</font></p>
<ol>
  <li><font face="Times New Roman, Times, serif">Во первых, так как человек большой 
    ранг громкостей и частот, то громкие звуки могут маскировать тихие, то есть 
    некоторое время после громких звуков, человек довольно трудно воспринимает 
    тихие.</font></li>
  <li><font face="Times New Roman, Times, serif">В некоторых случаях, человек 
    игнорирует окружающие искажения, если они некоторым образом маскируются.</font></li>
</ol>
<p><font face="Times New Roman, Times, serif">Данные особенности и используются 
  при скрытии данных в аудио-файлах.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif"><b><font size="4">Аудиосреда.</font></b><br>
  При скрытии данных в аудиофайле большое значение имеет выбор <a href="term.htm">контейнера</a>. 
  При скрытии, также достаточно часто требуется устойчивость скрытия к модификациям 
  <a href="term.htm">контейнера</a> и к воздействиям на <a href="term.htm">контейнер</a> 
  в процессе передачи.<br>
  </font></p>
<p align="justify"><font face="Times New Roman, Times, serif"><b><font size="4">Цифровое 
  представление звука.</font></b> <br>
  Существует два критических параметра, оказывающих влияние на качество цифрового 
  представления - частота квантования по времени и размерность квантования.<br>
  Для звука высокого качества достаточно часто используется размерность квантования 
  16 бит или 32 бит. Для более низкого качества - 8 бит. При всех этих размерностях, 
  естественно вносятся искажения, причем чем ниже размерность, тем больше искажение.<br>
  Наиболее часто используемые частоты квантования по времени: 8kHz, 10, 12, 16, 
  22.05, 44.1kHz.<br>
  Чем больше частота дискретизации, тем больше нам предоставляется возможностей 
  для внесения изменений. Аналогичная ситуация и для размерностей квантования.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif" size="4"><b>Передающая 
  среда.</b></font><font face="Times New Roman, Times, serif"><br>
  Существует очень много типов передающей среды для звука. Среди них можно выделить 
  4 класса (рис.&nbsp;8.):</font></p>
<p align="center"><img src="pic8.gif" width="300" height="387" alt="4 класса передающих сред"><br>
  <font face="Times New Roman, Times, serif" color="#000000">Рис. 8.</font></p>
<ol>
  <li><font face="Times New Roman, Times, serif"> Цифровая передача от начала 
    до конца (копирование с машины на машину и не модифицируется).</font></li>
  <li><font face="Times New Roman, Times, serif"> Перевод при передаче сигнала 
    в более высокие или более низкие частоты. Это преображение сохраняет абсолютную 
    амплитуду и фазу сигнала, но изменяет временные характеристики сигнала.</font></li>
  <li><font face="Times New Roman, Times, serif"> Аналоговая передача звука по 
    чистому каналу. Здесь абсолютная амплитуда и частоты не затрагиваются. Фазовые 
    характеристики, как правило, также сохраняются.</font></li>
  <li><font face="Times New Roman, Times, serif"> Проигрывание файла. Передача 
    по воздуху, через микрофон. В этом случае - воздействие незнакомых нелинейных 
    преобразований, оказывающих влияние на фазовые характеристики, амплитуду, 
    сдвиг частот, эхо и т.д.</font></li>
</ol>
<p><font face="Times New Roman, Times, serif">Тип квантования и тип передающей 
  среды необходимо учитывать при выборе метода сокрытия данных.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif"><b><font size="4">Методы 
  сокрытия.</font></b><br>
  <b>Сокрытие в наименее значимых битах.</b><br>
  В данном случае наименее значимые биты заменяются с использованной закодированной 
  бинарной строки, представляющей собой данные. Мы можем закодировать таким образом 
  большое количество данных. Обычно мы имеем следующее соотношение для вместимости 
  канала - 1Kb звука в секунду на 1 kHz. То есть, мы будем иметь 8Kb звука в секунду 
  в 8kHz и 44Kb в секунду для 44kHz. В этот объем звука и вставляются данные, 
  представляющие собой шум.<br>
  Очень большое влияние на качество сокрытия имеет содержание звука. Например, 
  можно встроить большое количество данных, и соответственно много шума в репортаж 
  со спортивного стадиона, и он не будет заметен. С другой стороны, шум сразу 
  будет заметен, если данные встраивать в струнный оркестр.<br>
  Главный недостаток данного метода - неустойчивость к преобразованиям. Встроенная 
  информация может быть уничтожена шумом в канале или изменением частоты квантования, 
  этот эффект может быть уменьшен путем включения избыточной информации, однако 
  эта технология используется только для цифровых передач.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif"><b>Фазовое кодирование.</b><br>
  Метод фазового кодирования работает путем подстановки вместо фазы начального 
  аудио сегмента соответствующей фазой скрываемых данных. Фазы последующих сегментов 
  настраиваются таким образом, чтобы сохранить относительную фазу между сегментами.<br>
  Метод фазового кодирования является одним из наиболее эффективных в терминах 
  соотношения сигнал/шум. Когда соотношение фаз между частотными компонентами 
  меняется очень сильно, появляется заметное фазовое рассеивание. Однако, до тех 
  пор, пока модификация фазы достаточно малая (достаточно мало по отношению к 
  слушателю, профессионалы могут заметить различия, которые не замечает средний 
  человек), может быть достигнуто не различаемое на слух кодирование.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Алгоритм фазового кодирования</font><font face="Times New Roman, Times, serif">:</font></p>
<div align="justify">
  <ol>
    <li> <font face="Times New Roman, Times, serif">Разбить звуковую последовательность 
      s[I] (0&nbsp;<u>&lt;</u>&nbsp;i&nbsp;<u>&lt;</u>&nbsp;I-1) на серию N коротких 
      сегментов, s<SUB>n</SUB>[i] где (0&nbsp;<u>&lt;</u>&nbsp;n&nbsp;<u>&lt;</u>&nbsp;N-1) 
      (рис. 9А, 9В).</font></li>
    <li><font face="Times New Roman, Times, serif">Применить K-точечное дискретное 
      преобразование Фурье к n-му сегменту s<SUB>n</SUB>[i], где (К=1/N), создать 
      матрицу фаз<b> </b><img src="frmls01.gif" width="60" height="20" align="absmiddle"> 
      и амплитуд <img src="frmls02.gif" width="64" height="22" align="absmiddle">, 
      k=0,…,K (рис. 9С).</font></li>
    <li><font face="Times New Roman, Times, serif">Вычислить и сохранить разницы 
      фаз между каждыми двумя сегментами для k=0,…,N-1 (рис. 9D): <i><b><img src="frmls03.gif" width="234" height="21" align="absmiddle"></b></i>.</font></li>
    <li><font face="Times New Roman, Times, serif">Бинарное множество данных представляется 
      как <i></i><img src="frmls04.gif" width="85" height="22" align="absmiddle"> 
      или <i><b><img src="frmls05.gif" width="88" height="22" align="absmiddle"></b></i>, 
      в зависимости от 0 или 1 (рис. 9E). Для сегмента S<SUB>0</SUB> создаем искусственную 
      абсолютную фазу <i><b><img src="frmls06.gif" width="90" height="22" align="absmiddle"></b></i>.</font></li>
    <li><font face="Times New Roman, Times, serif">Для всех остальных сегментов 
      создать новые фазы, используя фазовые разницы путем пересчета фазовых матриц 
      <i> <b><img src="frmls07.gif" width="238" height="23" align="absmiddle"></b></i>, 
      i=1,…,N (рис. 9F).</font></li>
    <li><font face="Times New Roman, Times, serif">Используя модифицированную 
      фазовую матрицу <i></i><img src="frmls08.gif" width="92" height="22" align="absmiddle"> 
      и оригинальную матрицу амплитуд &#151; <i></i><img src="frmls02.gif" width="64" height="22" align="absmiddle"> 
      модифицировать сигнал, используя обратное преобразование Фурье.</font></li>
    <li><font face="Times New Roman, Times, serif">Объединить сегменты.</font></li>
  </ol>
</div>
<ol>
</ol>
<p align="center"><font face="Times New Roman, Times, serif"><img src="pic9.gif" width="400" height="1031" alt="Фазовое кодирование"><br>
  <font color="#000000">Рис. 9.</font></font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Для раскодирования, 
  используется синхронизация последовательностей перед декодированием. Длина сегментов 
  (точки, в которых осуществляется разбиение сигнала) должны быть известны получателю. 
  Анализируя сигнал, мы вычисляем фазовую последовательность сегмента 0, которая 
  и представляет собой закодированную бинарную строку.<br>
  Данный метод позволяет скрывать данные, нечувствительно к звуковому восприятию.<br>
  </font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Оценка метода:<br>
  Рассеивание фаз выражается нарушении связей между сегментами в точках стыковки. 
  Минимизация разброса фаз ограничивает объем сокрытия данных. Одна из причин 
  разброса фаз - изменение фазы <i><b><img src="frmls09.gif" width="60" height="21" align="absmiddle"></b></i> 
  бинарным кодом. Для минимизации разброса, амплитуды данных фаз должны быть близки 
  друг к другу. Минимизация - наименьшая восприимчивость человека. С другой стороны 
  максимизация разброса повышает устойчивость сокрытия данных к шуму.<br>
  </font></p>
<p align="justify"><font face="Times New Roman, Times, serif"><b>Метод расширения 
  спектра</b>.<br>
  В обыкновенном канале передачи, часто очень желательно сконцентрировать информацию 
  в некотором узком регионе частотного спектра для сохранения доступной полосы 
  частот и уменьшить мощность.<br>
  С другой стороны, техника расширения спектра спроектирован для кодирования потока 
  информации путем рассеивания закодированных данных по всей полосе частот, настолько, 
  насколько это возможно. Это позволяет хорошо раскодировать данные, даже при 
  модификации некоторых частот посредством преобразований.<br>
  Метод непосредственного последовательного расширения спектра (НПРС) использует, 
  так называемые &quot;элементарные посылки&quot;. Так как сигнал является дискретным 
  по времени, мы можем использовать частоту отсчетов как частоту следования элементарных 
  посылок для кодирования.<br>
  Алгоритм:<br>
  В методе НПРС для кодирования и раскодирования данных необходим специальный 
  ключ, который генерируется с помощью генератора псевдослучайных чисел. Данный 
  генератор должен генерировать белый шум. Данный ключ определяет, в какие места 
  расширенного спектра будут вставляться данные.<br>
  Код обрабатывается несущей волной и псевдослучайной шумовой последовательностью, 
  которая имеет широкий спектр. Как результат, спектр данных становится очень 
  широким. Размазанные последовательность данных ослабляется и добавляется к файлу 
  как аддитивный случайный шум. При декодировании, сначала воздействуем сигналом 
  элементарных посылок, затем полосовым фильтром и определителем фазы. При декодировании 
  фазовые значения<img src="frmls10.gif" width="21" height="22" align="absmiddle"> 
  <i></i> и<img src="frmls11.gif" width="45" height="22" align="absmiddle"> <i></i> 
  интерпретируются как 0 и 1, которые представляют собой закодированную строку.<br>
  На рис. 10 изображен процесс встраивания данных.</font></p>
<p align="center"><img src="pic10.gif" width="419" height="296"><br>
  <font color="#000000" face="Times New Roman, Times, serif">Рис. 10.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Пошагово процесс 
  декодирования может быть записан следующим образом:</font></p>
<ol>
  <li><font face="Times New Roman, Times, serif"><a href="term.htm">Ключ</a> мы 
    знаем.</font></li>
  <li><font face="Times New Roman, Times, serif">Осуществляется синхронизация 
    сигнала и находятся начальная и конечная точки встраивания данных.</font></li>
  <li><font face="Times New Roman, Times, serif">Декодирование осуществляется 
    с известными частотой элементарных посылок, данных и <a href="term.htm">контейнера</a>.</font></li>
</ol>
<ol>
</ol>
<p align="justify"><font face="Times New Roman, Times, serif">Результаты данный метод 
  вставляет шум низкого уровня и он мало заметен на слух. Лучше данный метод применять 
  с протоколом коррекции ошибок для обеспечения целостности. Как правило. При 
  высоком качестве можно добиться результата 4 Кб в секунду.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif"><b>Встраивание данных 
  путем использования ЭХО.</b><br>
  Данная технология встраивает данные в звук путем использования эхо. Технология 
  модифицирует три параметра эхо - начальную амплитуду, частоту затухания и смещение 
  эха. В то время, как смещение или затухание уменьшается, происходит объединение 
  двух сигналов, и в определенной точке ухо не может различить различия между 
  двумя сигналами. Эхо воспринимается как дополнительный резонанс. Данную точку 
  довольно трудно определить напрямую. Она зависит от качества оригинальной записи, 
  типа звука и слушателя. Для большинства звуков и слушателей данная точка имеет 
  место примерно 1000 раз в секунду.<br>
  Кодер использует 2 временных задержки - одну, чтобы представить бинарную единицу 
  (смещение), а вторую - для бинарного нуля (смещение+дельта). Обе временные задержки 
  расположены ниже порога, когда человек может различить эхо, чем они меньше - 
  тем хуже они различимы человеком.<br>
  <b>Кодирование.</b><br>
  Процесс кодирования может быть представлен как система, которая имеет одну из 
  двух возможных системных функций. Во времени, системные функции являются дискретными 
  экспоненциальными, а различия выражаются только в задержках между импульсами 
  (рис. 11).</font></p>
<p align="center"><img src="pic11.gif" width="376" height="200"><br>
  <font face="Times New Roman, Times, serif" color="#000000">Рис. 11.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Для простоты, возьмем 
  только 2 импульса (один для копирования оригинального сигнала, и один - для 
  копирования эхо). Увеличение числа импульсов ведет к увеличению числа эхо. </font></p>
<p align="center"><img src="pic12.gif" width="420" height="257"><br>
  <font color="#000000" face="Times New Roman, Times, serif">Рис. 12.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Системная функция 
  на рис. 12А кодирует 1, а на рис. 12В - кодирует 0. </font><font face="Times New Roman, Times, serif">Закодированный 
  сигнал представлен на рис. 13. Задержка <i><b><img src="frmls12.gif" width="22" height="23" align="absmiddle"></b></i> 
  между оригинальным сигналом и эхо зависит от используемого ядра или системной 
  функции. Для 1 - задержка <i><b><img src="frmls13.gif" width="22" height="23" align="absmiddle"></b></i> 
  для 0 - <i><b><img src="frmls14.gif" width="22" height="23" align="absmiddle"></b></i>. 
  </font></p>
<p align="center"><img src="pic13.gif" width="450" height="225"><br>
  <font color="#000000" face="Times New Roman, Times, serif">Рис. 13.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Для кодирования 
  более, чем 1 бита сигнал разделяется на малые порции. Каждая индивидуальная 
  порция рассматривается как отдельный сигнал и кодируется с требуемым битом. 
  Окончательный сигнал есть конкатенация независимо закодированных сигналов. <br>
  </font></p>
<p align="center"><img src="pic14.gif" width="450" height="122"><br>
  <font face="Times New Roman, Times, serif" color="#000000">Рис. 14.</font> </p>
<p align="justify"><font face="Times New Roman, Times, serif">На рис. 14 сигнал 
  разделен на 7 порций, обозначенных a,b,c,d,e,f,g. Нам нужно, чтобы a,c,d,g содержали 
  1. Для них мы используем ядро 1 как системную функцию. Остальные порции кодируются 
  аналогично с ядром 0.<br>
  На рис. 15 представлен 1 шаг кодирования - создание эхо-сигналов 0 и 1. <br>
  </font></p>
<p align="center"><img src="pic15.gif" width="450" height="199"><br>
  <font face="Times New Roman, Times, serif" color="#000000">Рис. 15.</font> </p>
<p align="justify"><font face="Times New Roman, Times, serif">Далее вводятся смешивающие 
  сигналы для 1 и 0. Они представлены на рис. 16 (они являются дополнениями и 
  наклонные). Эхо-сигнал 1 умножается на смешивающий сигнал 1, а эхо-сигнал 0 
  - на смешивающий сигнал 0. Результаты суммируются. </font></p>
<p align="center"><img src="pic16.gif" width="450" height="308"><br>
  <font face="Times New Roman, Times, serif" color="#000000">Рис. 16.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Наклон в смешивающих 
  сигналах необходим для более гладкого изменения громкости результирующего сигнала. 
  <br>
  <b>Декодирование.</b> <br>
  Пусть кодирование произведено так, как описано выше - с двумя задержками для 
  0 и 1 - <i><b><img src="frmls13.gif" width="22" height="23" align="absmiddle"></b></i>, 
  <i><b><img src="frmls14.gif" width="22" height="23" align="absmiddle"></b></i>. 
  Извлечение скрытых данных включает детектирование пространства между эхо-сигналами. 
  Для этого исследуется амплитуда (в двух местах) автокорреляционной функции кепстра 
  закодированного сигнала: <i><b><img src="frmls15.gif" width="181" height="32" align="absmiddle"></b></i>. 
  <br>
  Следующая процедура показывает пример процесса декодирования.<br>
  Возьмем пример сигнала, который является серией импульсов, разделенных последовательностью 
  интервалов, причем импульсы последовательно затухают (рис. 17).<br>
  </font></p>
<p align="center"><img src="pic17.gif" width="275" height="289"><br>
  <font face="Times New Roman, Times, serif" color="#000000">Рис. 17.</font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Следующий шаг - 
  найти кепстр для эхо. Результат нахождения кепстра делает пространство между 
  эхо и оригинальным сигналом намного яснее.<br>
  К сожалению, результат нахождения кепстра также дублирует эхо каждые <i><b><img src="frmls16.gif" width="15" height="20" align="absmiddle"></b></i> 
  секунд. Более того, амплитуда импульсов эха мало отличается от оригинального 
  сигнала и их трудно детектировать. Решение этой проблемы - брать автокорреляцию 
  кепстра.</font><font face="Times New Roman, Times, serif"><br>
  </font></p>
<p align="center"><img src="pic18.gif" width="190" height="211"><br>
  <font face="Times New Roman, Times, serif" color="#000000">Рис.18.</font> </p>
<p align="justify"><font face="Times New Roman, Times, serif">Получим эхо сигнала 
  с задержкой <i><b><img src="frmls16.gif" width="15" height="20" align="absmiddle"></b></i> 
  с ядром на рис. 18. Результат - на рис. 19. Был получен пик в позиции первого 
  импульса на расстоянии <i> <b><img src="frmls14.gif" width="22" height="23" align="absmiddle"></b></i> 
  или <i><b><img src="frmls13.gif" width="22" height="23" align="absmiddle"></b></i> 
  от оригинального сигнала. Видим, что случайный шум затухает точно также, как 
  и все импульсы после первого.<br>
  </font></p>
<p align="center"><img src="pic19.gif" width="309" height="295"><br>
  <font face="Times New Roman, Times, serif" color="#000000">Рис. 19.</font> </p>
<p align="justify"><font face="Times New Roman, Times, serif">Правило, определяющее, 
  единица или ноль закодированы в данном месте, основано на оценке задержки между 
  оригинальным сигналом и задержкой пика в автокорреляции. Мы кодируем в данном 
  месте единицу, если данная разница более близка к <i><b><img src="frmls13.gif" width="22" height="23" align="absmiddle"></b></i> 
  секунд, чем к <i><b><img src="frmls14.gif" width="22" height="23" align="absmiddle"></b></i>, 
  и как 0, в обратном случае.<br>
  Результаты. Данный метод позволяет прятать данные приблизительно в объеме 16Кб 
  в секунду.<br>
  </font></p>
<p align="justify"><font face="Times New Roman, Times, serif"><b>Дополнительные технологии</b><br>
  1. Адаптивное затухание данных. Оптимальный фактор затухания зависит от уровня 
  шума в <a href="term.htm">контейнере</a>. Адаптивное затухание позволяет делать 
  малым уровень шума на одних сегментах и увеличивать уровень шума там где его 
  очень много. <br>
  2. Внесение избыточности и протоколов коррекции ошибок. Для компенсирования 
  ошибок в силу зашумленности канала и преобразований, предпочтительно использовать 
  протоколы коррекции ошибок.<br>
  4. Анализ содержания звука. Для повышения качества внедрения данных, полезно 
  внедрять шум избирательно. Уровень шума характеризуется уровнем изменений соседних 
  отсчетов сигнала.</font></p>
<p align="center"><font face="Times New Roman, Times, serif"><img src="frmls17.gif" width="300" height="52"></font></p>
<p align="justify"><font face="Times New Roman, Times, serif">Здесь, N - число 
  отсчетов, а Smax - максимальное изменение. Этот параметр используется для разграничения 
  звука по уровню зашумленности.</font></p>
<p align="center"><object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=4,0,2,0" width="50" height="70">
    <param name=movie value="button10.swf">
    <param name=quality value=high>
    <param name="BASE" value=".">
    <param name="BGCOLOR" value="#ebf4d5">
    <embed src="button10.swf" base="."  quality=high pluginspage="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="50" height="70" bgcolor="#ebf4d5">
    </embed> 
  </object><object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=4,0,2,0" width="50" height="70">
    <param name=movie value="button11.swf">
    <param name=quality value=high>
    <param name="BASE" value=".">
    <param name="BGCOLOR" value="#ebf4d5">
    <embed src="button11.swf" base="."  quality=high pluginspage="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="50" height="70" bgcolor="#ebf4d5">
    </embed> 
  </object> </p>
</body>
</html>
